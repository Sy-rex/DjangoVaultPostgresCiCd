name: Deploy Django App

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  K8S_NAMESPACE: django-app

jobs:
  build-and-deploy:
    # ВАЖНО: используем ваш self-hosted runner
    runs-on: self-hosted 
    
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kubernetes context
        run: |
          kubectl config use-context minikube

      - name: Build Django Docker image
        run: |
          # Собираем образ Django локально
          docker build -t django-kubernetes-app:latest .
          
          # Загружаем образ в minikube
          minikube image load django-kubernetes-app:latest

      - name: Build Vault Docker image
        run: |
          # Собираем образ Vault локально
          docker build -t vault-custom:latest -f vault/Dockerfile vault/
          
          # Загружаем образ в minikube
          minikube image load vault-custom:latest

      - name: Deploy and configure Vault
        shell: powershell
        run: |
          # Создаем namespace vault
          kubectl create namespace vault --dry-run=client -o yaml | kubectl apply -f -
          
          # Применяем манифесты Vault
          kubectl apply -f k8s-manifests/vault/namespace.yaml
          kubectl apply -f k8s-manifests/vault/deployment.yaml
          kubectl apply -f k8s-manifests/vault/service.yaml
          
          # Ожидаем готовности Vault pod
          Write-Host "Ожидаем готовности Vault..."
          $maxAttempts = 30
          $attempt = 0
          $podReady = $false
          
          while ($attempt -lt $maxAttempts -and -not $podReady) {
              Start-Sleep -Seconds 5
              $podStatus = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].status.phase}' 2>&1
              if ($podStatus -eq "Running") {
                  $containerReady = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].status.containerStatuses[0].ready}' 2>&1
                  if ($containerReady -eq "true") {
                      $podReady = $true
                      Write-Host "Pod готов!"
                      break
                  }
              }
              $attempt++
              Write-Host "Попытка $attempt/$maxAttempts, статус: $podStatus"
              
              # Показываем логи при проблемах
              if ($attempt % 5 -eq 0) {
                  $podName = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}' 2>&1
                  Write-Host "Логи pod $podName :"
                  kubectl logs $podName -n vault --tail=20 2>&1
              }
          }
          
          if (-not $podReady) {
              Write-Host "Pod не готов, но продолжаем..."
              $podName = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}' 2>&1
              Write-Host "Статус pod:"
              kubectl get pods -n vault -l app=vault 2>&1
              Write-Host "Логи pod:"
              kubectl logs $podName -n vault 2>&1
              Write-Host "Описание pod:"
              kubectl describe pod $podName -n vault 2>&1
          }
          
          # Даем дополнительное время на инициализацию
          Start-Sleep -Seconds 10
          
          # Получаем имя pod Vault
          $VAULT_POD = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}'
          Write-Host "Используем pod: $VAULT_POD"
          
          # Проверяем, что pod существует и контейнер запущен
          $containerStatus = kubectl get pod $VAULT_POD -n vault -o jsonpath='{.status.containerStatuses[0].ready}' 2>&1
          Write-Host "Статус контейнера: $containerStatus"
          
          # Ждем, пока контейнер станет ready
          if ($containerStatus -ne "true") {
              Write-Host "Контейнер не готов, ждем еще..."
              $waitAttempts = 0
              while ($waitAttempts -lt 20 -and $containerStatus -ne "true") {
                  Start-Sleep -Seconds 3
                  $containerStatus = kubectl get pod $VAULT_POD -n vault -o jsonpath='{.status.containerStatuses[0].ready}' 2>&1
                  $waitAttempts++
                  Write-Host "Попытка $waitAttempts/20, статус: $containerStatus"
              }
          }
          
          if ($containerStatus -eq "true") {
              # Настраиваем KV движок версии 2 (если еще не включен)
              Write-Host "Настраиваем KV движок версии 2..."
              try {
                  $null = kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault secrets enable -path=secret kv-v2" 2>&1
                  if ($LASTEXITCODE -ne 0) { 
                      Write-Host "KV движок уже включен"
                  }
              } catch {
                  Write-Host "KV движок уже включен или ошибка"
              }
              
              # Записываем секреты для Django приложения
              Write-Host "Записываем секреты для Django приложения..."
              kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault kv put secret/django-app/database db_name=django_prod db_user=django_user db_password=SuperSecret123! secret_key=very-secret-key-prod" 2>&1 | Out-Null
              
              # Создаем политику доступа
              Write-Host "Настраиваем политику доступа..."
              $policy = 'path "secret/data/django-app/*" { capabilities = ["read"] }'
              try {
                  $null = echo $policy | kubectl exec -i $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault policy write django-app -" 2>&1
                  if ($LASTEXITCODE -ne 0) { 
                      Write-Host "Политика уже существует"
                  }
              } catch {
                  Write-Host "Политика уже существует или ошибка"
              }
              
              # Проверяем секреты
              Write-Host "Проверяем записанные секреты..."
              kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault kv get secret/django-app/database" 2>&1 | Out-Null
              
              Write-Host "Vault успешно установлен и настроен!"
          } else {
              Write-Host "Контейнер Vault не готов, пропускаем настройку. Проверьте логи pod."
              exit 1
          }

      - name: Deploy to Minikube
        run: |
          # Создаем namespace если нет
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Секреты (См. пояснение ниже - т.к. это CI, секрет должен уже быть или создаваться тут)
          # В лабе предполагается ручное создание, поэтому пропустим создание секрета в CI
          
          # Применяем манифесты
          kubectl apply -f k8s-manifests/namespace.yaml
          kubectl apply -f k8s-manifests/configmap.yaml
          kubectl apply -f k8s-manifests/postgres/
          kubectl apply -f k8s-manifests/deployment.yaml
          kubectl apply -f k8s-manifests/service.yaml
          kubectl apply -f k8s-manifests/ingress.yaml
          
          # Форсируем обновление образа (rollout restart)
          kubectl rollout restart deployment/django-deployment -n ${{ env.K8S_NAMESPACE }}
