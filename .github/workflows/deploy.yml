name: Deploy Django App

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

env:
  K8S_NAMESPACE: django-app

jobs:
  build-and-deploy:
    # ВАЖНО: используем ваш self-hosted runner
    runs-on: self-hosted 
    
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Kubernetes context
        run: |
          kubectl config use-context minikube

      - name: Build Django Docker image
        run: |
          # Собираем образ Django локально
          docker build -t django-kubernetes-app:latest .
          
          # Загружаем образ в minikube
          minikube image load django-kubernetes-app:latest

      - name: Build Vault Docker image
        run: |
          # Собираем образ Vault локально
          docker build -t vault-custom:latest -f vault/Dockerfile vault/
          
          # Загружаем образ в minikube
          minikube image load vault-custom:latest

      - name: Deploy and configure Vault
        shell: powershell
        run: |
          # Создаем namespace vault
          kubectl create namespace vault --dry-run=client -o yaml | kubectl apply -f -
          
          # Применяем манифесты Vault
          kubectl apply -f k8s-manifests/vault/namespace.yaml
          kubectl apply -f k8s-manifests/vault/deployment.yaml
          kubectl apply -f k8s-manifests/vault/service.yaml
          
          # Ожидаем готовности Vault pod
          Write-Host "Ожидаем готовности Vault..."
          $maxAttempts = 30
          $attempt = 0
          $podReady = $false
          
          while ($attempt -lt $maxAttempts -and -not $podReady) {
              Start-Sleep -Seconds 5
              $podStatus = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].status.phase}' 2>&1
              if ($podStatus -eq "Running") {
                  $containerReady = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].status.containerStatuses[0].ready}' 2>&1
                  if ($containerReady -eq "true") {
                      $podReady = $true
                      Write-Host "Pod готов!"
                      break
                  }
              }
              $attempt++
              Write-Host "Попытка $attempt/$maxAttempts, статус: $podStatus"
              
              # Показываем логи при проблемах
              if ($attempt % 5 -eq 0) {
                  $podName = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}' 2>&1
                  Write-Host "Логи pod $podName :"
                  kubectl logs $podName -n vault --tail=20 2>&1
              }
          }
          
          if (-not $podReady) {
              Write-Host "Pod не готов, но продолжаем..."
              $podName = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}' 2>&1
              Write-Host "Статус pod:"
              kubectl get pods -n vault -l app=vault 2>&1
              Write-Host "Логи pod:"
              kubectl logs $podName -n vault 2>&1
              Write-Host "Описание pod:"
              kubectl describe pod $podName -n vault 2>&1
          }
          
          # Даем дополнительное время на инициализацию
          Start-Sleep -Seconds 10
          
          # Получаем имя pod Vault
          $VAULT_POD = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}'
          Write-Host "Используем pod: $VAULT_POD"
          
          # Проверяем, что pod существует и контейнер запущен
          $containerStatus = kubectl get pod $VAULT_POD -n vault -o jsonpath='{.status.containerStatuses[0].ready}' 2>&1
          Write-Host "Статус контейнера: $containerStatus"
          
          # Ждем, пока контейнер станет ready
          if ($containerStatus -ne "true") {
              Write-Host "Контейнер не готов, ждем еще..."
              $waitAttempts = 0
              while ($waitAttempts -lt 20 -and $containerStatus -ne "true") {
                  Start-Sleep -Seconds 3
                  $containerStatus = kubectl get pod $VAULT_POD -n vault -o jsonpath='{.status.containerStatuses[0].ready}' 2>&1
                  $waitAttempts++
                  Write-Host "Попытка $waitAttempts/20, статус: $containerStatus"
              }
          }
          
          if ($containerStatus -eq "true") {
              # Настраиваем KV движок версии 2 (если еще не включен)
              Write-Host "Настраиваем KV движок версии 2..."
              try {
                  $null = kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault secrets enable -path=secret kv-v2" 2>&1
                  if ($LASTEXITCODE -ne 0) { 
                      Write-Host "KV движок уже включен"
                  }
              } catch {
                  Write-Host "KV движок уже включен или ошибка"
              }
              
              # Записываем секреты для Django приложения
              Write-Host "Записываем секреты для Django приложения..."
              kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault kv put secret/django-app/database db_name=django_prod db_user=django_user db_password=SuperSecret123! secret_key=very-secret-key-prod" 2>&1 | Out-Null
              
              # Создаем политику доступа
              Write-Host "Настраиваем политику доступа..."
              $policy = 'path "secret/data/django-app/*" { capabilities = ["read"] }'
              try {
                  $null = echo $policy | kubectl exec -i $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault policy write django-app -" 2>&1
                  if ($LASTEXITCODE -ne 0) { 
                      Write-Host "Политика уже существует"
                  }
              } catch {
                  Write-Host "Политика уже существует или ошибка"
              }
              
              # Проверяем секреты
              Write-Host "Проверяем записанные секреты..."
              kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault kv get secret/django-app/database" 2>&1 | Out-Null
              
              Write-Host "Vault успешно установлен и настроен!"
          } else {
              Write-Host "Контейнер Vault не готов, пропускаем настройку. Проверьте логи pod."
              exit 1
          }

      - name: Create Django secrets from Vault
        shell: powershell
        run: |
          # Получаем секреты из Vault и создаем Kubernetes Secret
          Write-Host "Получаем секреты из Vault..."
          
          # Получаем имя pod Vault
          $VAULT_POD = kubectl get pods -n vault -l app=vault -o jsonpath='{.items[0].metadata.name}'
          Write-Host "Используем Vault pod: $VAULT_POD"
          
          # Получаем секреты из Vault в JSON формате
          $vaultJson = kubectl exec $VAULT_POD -n vault -c vault -- sh -c "VAULT_ADDR=http://localhost:8200 VAULT_TOKEN=root vault kv get -format=json secret/django-app/database" 2>&1 | Out-String
          
          # Парсим JSON в PowerShell
          $vaultData = $vaultJson | ConvertFrom-Json
          $dbUser = $vaultData.data.data.db_user
          $dbPassword = $vaultData.data.data.db_password
          $secretKey = $vaultData.data.data.secret_key
          
          Write-Host "Создаем Kubernetes Secret из секретов Vault..."
          
          # Создаем secret через kubectl create с dry-run и apply
          kubectl create secret generic django-secrets `
            --namespace django-app `
            --from-literal=db_user=$dbUser `
            --from-literal=db_password=$dbPassword `
            --from-literal=secret_key=$secretKey `
            --dry-run=client -o yaml | kubectl apply -f -
          
          Write-Host "Secret django-secrets создан успешно!"

      - name: Deploy to Minikube
        shell: powershell
        run: |
          # Создаем namespace если нет
          kubectl create namespace ${{ env.K8S_NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
          
          # Применяем манифесты (без PostgreSQL, так как он зависит от secret)
          kubectl apply -f k8s-manifests/namespace.yaml
          kubectl apply -f k8s-manifests/configmap.yaml
          
          # Деплоим PostgreSQL (secret уже создан на предыдущем шаге)
          kubectl apply -f k8s-manifests/postgres/
          
          # Ждем готовности PostgreSQL
          Write-Host "Ожидаем готовности PostgreSQL..."
          kubectl wait --for=condition=ready pod -l app=postgres -n ${{ env.K8S_NAMESPACE }} --timeout=180s
          
          # Проверяем, что PostgreSQL действительно принимает подключения
          Write-Host "Проверяем доступность PostgreSQL..."
          $postgresPod = kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=postgres -o jsonpath='{.items[0].metadata.name}'
          $postgresReady = $false
          $postgresAttempts = 0
          $maxPostgresAttempts = 15
          
          while ($postgresAttempts -lt $maxPostgresAttempts -and -not $postgresReady) {
              $postgresAttempts++
              Write-Host "Проверка доступности PostgreSQL: $postgresAttempts/$maxPostgresAttempts"
              
              # Проверяем через psql или pg_isready
              $pgCheck = kubectl exec $postgresPod -n ${{ env.K8S_NAMESPACE }} -- sh -c "pg_isready -U django_user -d django_prod" 2>&1
              if ($LASTEXITCODE -eq 0) {
                  $postgresReady = $true
                  Write-Host "PostgreSQL готов к подключениям!"
                  break
              } else {
                  Write-Host "PostgreSQL еще не готов, ждем..."
                  Start-Sleep -Seconds 5
              }
          }
          
          if (-not $postgresReady) {
              Write-Host "PostgreSQL не готов после $maxPostgresAttempts попыток, но продолжаем..."
              Write-Host "Логи PostgreSQL:"
              kubectl logs $postgresPod -n ${{ env.K8S_NAMESPACE }} --tail=30
          }
          
          # Даем дополнительное время PostgreSQL на полную инициализацию
          Write-Host "Ждем полной инициализации PostgreSQL..."
          Start-Sleep -Seconds 10
          
          # Деплоим Django приложение
          kubectl apply -f k8s-manifests/deployment.yaml
          kubectl apply -f k8s-manifests/service.yaml
          kubectl apply -f k8s-manifests/ingress.yaml
          
          # Форсируем обновление образа (rollout restart)
          kubectl rollout restart deployment/django-deployment -n ${{ env.K8S_NAMESPACE }}
          
          # Ждем готовности pods Django
          Write-Host "Ожидаем готовности Django pods..."
          kubectl wait --for=condition=ready pod -l app=django-app -n ${{ env.K8S_NAMESPACE }} --timeout=120s
          
          # Даем время на полную инициализацию Django pods
          Start-Sleep -Seconds 5
          
          # Получаем имя pod Django
          $DJANGO_POD = kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=django-app -o jsonpath='{.items[0].metadata.name}'
          Write-Host "Используем pod: $DJANGO_POD"
          
          # Запускаем миграции Django с повторными попытками
          Write-Host "Запускаем миграции Django..."
          $migrationAttempts = 0
          $maxMigrationAttempts = 5
          $migrationSuccess = $false
          
          while ($migrationAttempts -lt $maxMigrationAttempts -and -not $migrationSuccess) {
              $migrationAttempts++
              Write-Host "Попытка запуска миграций: $migrationAttempts/$maxMigrationAttempts"
              
              $migrationOutput = kubectl exec $DJANGO_POD -n ${{ env.K8S_NAMESPACE }} -- python manage.py migrate 2>&1 | Out-String
              Write-Host $migrationOutput
              
              if ($LASTEXITCODE -eq 0) {
                  $migrationSuccess = $true
                  Write-Host "Миграции выполнены успешно!"
                  break
              } else {
                  Write-Host "Миграции завершились с ошибкой, код: $LASTEXITCODE"
                  if ($migrationAttempts -lt $maxMigrationAttempts) {
                      Write-Host "Ждем 10 секунд перед повторной попыткой..."
                      Start-Sleep -Seconds 10
                  }
              }
          }
          
          if (-not $migrationSuccess) {
              Write-Host "Не удалось выполнить миграции после $maxMigrationAttempts попыток"
              Write-Host "Проверьте логи pod: $DJANGO_POD"
              kubectl logs $DJANGO_POD -n ${{ env.K8S_NAMESPACE }} --tail=50
              exit 1
          }
